<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Retrofiting Existing Implementations</title><link rel="stylesheet" type="text/css" href="style.css"><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot"><link rel="home" href="index.html" title="Storing Trust Policy"><link rel="up" href="index.html" title="Storing Trust Policy"><link rel="prev" href="storing-trust-dbus.html" title="Representation: DBus API"><link rel="next" href="storing-trust-existing.html" title="Existing Trust Storage Implementations"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Retrofiting Existing Implementations</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="storing-trust-dbus.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="storing-trust-existing.html">Next</a></td></tr></table><hr></div><div class="article"><div class="titlepage"><div><div><h1 class="title"><a name="storing-trust-retrofit"></a>Retrofiting Existing Implementations</h1></div></div><hr></div><div class="toc"><dl class="toc"><dt><span class="sect1"><a href="storing-trust-retrofit.html#retrofit-anchors">1. Retrofit: Bundle of anchors</a></span></dt><dt><span class="sect1"><a href="storing-trust-retrofit.html#retrofit-callback">2. Retrofit: Extra validation</a></span></dt><dt><span class="sect1"><a href="storing-trust-retrofit.html#retrofit-nss-trust">3. Retrofit: NSS trust objects</a></span></dt><dt><span class="sect1"><a href="storing-trust-retrofit.html#rerofit-openssl-x509-store">4. Retrofit: OpenSSL X509_STORE</a></span></dt></dl></div><p>In an ideal world all implementations would move to this shared
		model of trust policy as soon as possible. However in the real
		world these things take time. Here we discuss various strategies
		for retrofitting existing implementations to be able to consume
		this stored data.</p><p>While such retrofits result in ignoring certain trust policy by
		a given implementation, there are concrete benefits of sharing
		even just some of the trust information. Such an interim retrofit
		produces coherent results for many current real world use cases.
		It is thus better than having all the crypto library implementations
		use their own source for trust policy.</p><p>Such a retrofit should be an interim measure.</p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="retrofit-anchors"></a>1. Retrofit: Bundle of anchors</h2></div></div></div><p>If a crypto library expects an input of a set of anchor certificate authorities
		and nothing more, then it is possible to lookup all acceptable anchors from
		the store. Anchors that no not match the necessary trust policy would be
		filtered out before handing them over to the validation algorithms.</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="retrofit-callback"></a>2. Retrofit: Extra validation</h2></div></div></div><p>If a crypto library allows access to the certificate chain before, during (via a
		callback) or after validation, then it is possible to check each certificate\
		in the chain against the blacklist.</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="retrofit-nss-trust"></a>3. Retrofit: NSS trust objects</h2></div></div></div><p>It is possible to model NSS PKCS#11 trust objects on top of an underlying storage
		based on attached certificate extensions. This will only enforce the KeyUsage
		and ExtendedKeyUsage extensions. Blacklists are modeled by marking all usages
		as untrusted.</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="rerofit-openssl-x509-store"></a>4. Retrofit: OpenSSL X509_STORE</h2></div></div></div><p>It is possible to model an OpenSSL X509_STORE implementation on top of an
		underlying storage based on attached certificate extensions. This will only
		enforce the ExtendedKeyUsage extensions. Blacklists are enforced by rejecting all
		usages.</p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="storing-trust-dbus.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="storing-trust-existing.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Representation: DBus API </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Existing Trust Storage Implementations</td></tr></table></div></body></html>
